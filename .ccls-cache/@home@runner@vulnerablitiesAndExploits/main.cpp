#include <iostream>
#include <string.h>
#include <stdio.h>
#include <string>
#include <assert.h>

using namespace std;

void generateFullName(char * fullName, int sizeFullName,
                    const char firstName[], const char lastName[]);

void arrayVulnerability(int indexNum);
  void arrayWorking();
  void arrayExploit();
void ansiVulnerability();
  void ansiWorking();
  void ansiExploit();
void arcVulnerability();
  void arcWorking();
  void arcExploit();
void heapVulnerability(string password, char name[]);
  void heapWorking();
  void heapExploit();
void integerVulnerability(string firstName, string lastName);
  void integerWorking();
  void integerExploit();
void pointerVulnerability(char username[], char password[]);
  void pointerWorking();
  void pointerExploit();
void stackVulnerability(char str[]);
  void stackWorking();
  void stackExploit();
void vtableVulnerability(int i, long * b);
  void vtableWorking();
  void vtableExploit();

using namespace std;

int main() {

  int vulReference{0};
  cout << "#  VULNERABILITY MENU \n"
       << "================================= \n"
       << "1. Array Index \n"                      //Finished
       << "2. ANSI-Unicode conversion \n"          //Working Alexander
       << "3. ARC injection \n"
       << "4. Heap spraying \n"                    //Working Mark
       << "5. Integer overflow \n"                 //Finished
       << "6. Pointer subterfuge \n"               //Finished
       << "7. Stack smashing \n"                   //Finished
       << "8. VTable spraying \n"                  //Working Steve
       << "0. QUIT PROGRAM \n"                     //Finished
       << "================================= \n"
       << "Select a vulnerability from the list, or type 0 to quit!\n";
  do{
    cout << "Menu Option: ";
    cin >> vulReference;
    switch(vulReference)
      {
        case 0 :
        cout << "Quitting program, thank you!\n";
        break;
        case 1 :
        cout << "Selected Array Index\n" << endl;
        arrayWorking();
        break;
        case 2 :
        cout << "Selected ANSI-Unicode conversion\n";
        ansiWorking();
        break;
        case 3 :
        cout << "Selected ARC injection\n";
        arcWorking();
        break;
        case 4 :
        cout << "Selected Heap spraying\n";
        heapWorking();
        break;
        case 5 :
        cout << "Selected Integer overflow\n";
        integerWorking();
        break;
        case 6 :
        cout << "Selected Pointer subterfuge\n";
        pointerWorking();
        break;
        case 7 :
        cout << "Selected Stack smashing\n";
        stackWorking();
        break;
        case 8 :
        cout << "Selected VTable spraying\n";
        vtableWorking();
        break;
        
        default :
        cout << "Invalid input" << endl 
             << "Select a vulnerability from the list, or type 0 to quit!\n";
      }
    cout << endl;
  } while (vulReference != 0);
  return 0;
} 

/* =====================================================
*              1. ARRAY INDEX
*  ===================================================== */

/*************************************
 * ARRAY VULNERABILTY
 * 1. There must be an array and an array index variable
 * 2. The array index variable must be reachable through external input.
 * 3. There must not be bounds checking on the array index variable.
 ****************************************/
void arrayVulnerability(int indexNum)
{
    int array[4] {0,0,0,0};
    bool authenticated = false;
    array[indexNum] = -1;
    
  if(indexNum == 1)
    cout << "Your're still not authenticated!\n";
  else
    cout << "Cheeky cheeky, winky winky, you're in!\n";
}

/**************************************
 * ARRAY WORKING
 * Call arrayVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void arrayWorking()
{
  
  int indexNumWorking = 1;

  cout << "Running arrayWorking parameters: \n";
  arrayVulnerability(indexNumWorking);
  cout << "\n[H@X] >> Attempting to run exploited code:\n";
  arrayExploit(); // Call on Exploit code
}

/**************************************
 * ARRAY EXPLOIT
 * 1. The attacker provides an array index value outside the expected range
 * 2. The attacker must be able to provide input or redirect
 *    existing input into the array at the index he provided
 * 3. The injected value must alter program state in a way
 *    that is desirable to the attacker
 *************************************/
void arrayExploit()
{
  
    int indexNumBroken = 4;

  arrayVulnerability(indexNumBroken);
    cout << "Crash";
}

/* =====================================================
*              2. ANSI-UNICODE CONVERSION
*  ===================================================== */

/*************************************
 * ANSI VULNERABILTY
 * 1. - There must be a buffer where the basetype is greater than one
 * 2. - Validation of the buffer must check the size of the buffer rather than the
        number of elements in the buffer.
 ****************************************/
void ansiVulnerability(/* feel free to add parameters */)
{
  // Prompt for the actor and movie that you want to be concatinated.
  string actor;
  string movie;
  cout << "Enter your favorite actor";
  cin >> actor;
  cout << "Enter your favorite movie";

  char actorMovieConcat[512];
  
//   short unicodeText1[256]; 
//   short unicodeText2[256];
  
//   inputUnicodeText(unicodeText1, 256);
//   copyUnicodeText(unicodeText1 /* source buffer */, unicodeText2 /* destination buffer */,

//   sizeof(unicodeText2) /* Should be 256 not 512! */);
}

/**************************************
 * ANSI WORKING
 * Call ansiVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void ansiWorking()
{
  ansiVulnerability(/* parameters with non-malicious data */);
  cout << "\n[H@X] >> Attempting to run exploited code:\n";
  ansiExploit(); // Call on Exploit code
}


/**************************************
 * ANSI EXPLOIT
 * 1. - The attacker must provide more than half as much data into the
        outwardly facing buffer as it is designed to hold.
 * 2. - From here, a variety of injection attacks are possible. The most likely
        candidates are stack smashing or heap smashing. In the above example,
        the third parameter of the copyUnicodeText() function is the number
        of elements in the string (256 elements), not the size of the string (512
        bytes). The end result is a buffer overrun of 256 bytes.
 *************************************/
void ansiExploit()
{
   ansiVulnerability(/* parameters with malicious data */);
}

/* =====================================================
*              3. ARC INJECTION
*  ===================================================== */

/*************************************
 * ARC VULNERABILTY
 * 1. - There must be a function pointer used in the code.
 * 2. - Through some vulnerability, there must be a way for user input to
        overwrite the function pointer. This typically happens through a stack
        buffer vulnerability.
 * 3. - After the memory is overwritten, the function pointer must be
        dereferenced.
 ****************************************/
void arcVulnerability(/* feel free to add parameters */)
{
  
}

/**************************************
 * ARC WORKING
 * Call arcVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void arcWorking()
{
  arcVulnerability(/* parameters with non-malicious data */);
  cout << "\n[H@X] >> Attempting to run exploited code:\n";
  arcExploit(); // Call on Exploit code
}

/**************************************
 * ARC EXPLOIT
 * 1. - The attacker must exploit a vulnerability allowing unintended access to
        the function pointer.
 * 2. - The attacker must have the address to another function which is to be
        used to replace the existing function pointer.
 *************************************/
void arcExploit()
{
   arcVulnerability(/* parameters with malicious data */);
}

/* =====================================================
*              4. HEAP SPRAYING
*  ===================================================== */

/*************************************
 * HEAP VULNERABILTY
 * 1. - There must be two adjacent heap buffers.
 * 2. - The first buffer must be reachable through external input.
 * 3. - The mechanism to fill the buffer from the external input must not
        correctly check for the buffer size.
 * 4. - The second buffer must be released before the first.
 * 5. - The first buffer must be overrun (extend beyond the intended limits of
        the array).
 ****************************************/
void heapVulnerability(string password, char name[])
{
  cout << "What is your Name? ";
  cout << name;

}

/**************************************
 * HEAP WORKING
 * Call heapVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void heapWorking()
{
 char * name = new char[16];
 name = "Team 7";
 string password = "A very long password.....!!!!";
   
 heapVulnerability(password, name);
  
 cout << "\n[H@X] >> Attempting to run exploited code:\n";
 heapExploit(); // Call on Exploit code
}

/**************************************
 * HEAP EXPLOIT
 * 1. - The attacker must provide more data into the outwardly facing heap
        buffer than the buffer is designed to hold.
 * 2. - The attacker must know the layout of the Memory Control Block (MCB)
        (essentially a linked list) residing just after the buffer.
 * 3. - The attacker must provide a new MCB containing both the location of
        the memory overwrite and the new data to be overwritten.

 *************************************/
void heapExploit()
{
  char * name = new char[16];
  name = "A good name that should break this code and spray the heap";
  string password = "A very long password.....!!!!";
  
   heapVulnerability(password, name);
}

/* =====================================================
*              5. INTEGER OVERFLOW
*  ===================================================== */

/*************************************
 * INTEGER VULNERABILTY
 * 1. - There must be a security check represented by an expression.
 * 2. - The expression must have the potential for overflow.
 * 3. - At least one of the numbers used to compute the sentinel must be
        reachable through external input. This sentinel is a variable used to make
        the security decision from the first requirement.
 ****************************************/
void integerVulnerability(string firstName, string lastName)
{
  cout << "First name: ";
  cout << firstName << "\n";
  cout << "Last name:  ";
  cout  << lastName << "\n";

// generate and display the full name
   char fullName[15];
   generateFullName(fullName, 512, firstName.c_str(), lastName.c_str());
   cout << "\tFull name: " << fullName << endl;
}

/******************************************************************
 * GENERATE FULL NAME : Create a full name from the components
 ******************************************************************/
void generateFullName(char * fullName, int sizeFullName,
                    const char firstName[], const char lastName[])
{
    
   unsigned char numUsed = 0;
 
   // copy last name
   for (const char * p = lastName; *p; p++)
      if (++numUsed < sizeFullName) // if we have space for 1 more
        *(fullName++) = *p;
 
   // copy on the comma and the space
   if (numUsed + 2 < sizeFullName)    // if we have space for 2 more
   {
      *(fullName++) = ',';
      *(fullName++) = ' ';
      numUsed += 2;
   }
 
   // copy first name
   for (const char * p = firstName; *p; p++)
      if (++numUsed < sizeFullName)  // if we have space for 1 more
        *(fullName++) = *p;
 
   // null character
   if (++numUsed < sizeFullName)    // if we have space for 1 more
      *fullName = '\0';
}


/**************************************
 * INTEGER WORKING
 * Call integerVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void integerWorking()
{
  string firstName = "Bob";
  string lastName = "The Builder";

  integerVulnerability(firstName, lastName);
  cout << "\n[H@X] >> Attempting to run exploited code:\n";
  integerExploit(); // Call on Exploit code
}

/**************************************
 * INTEGER EXPLOIT
 * 1. - Provide input, either a buffer size or a single value, that is directly or
        indirectly used in the vulnerable expression.
 * 2. - The input must exceed the valid bounds of the data-type, resulting in an
        overflow or underflow condition.
 *************************************/
void integerExploit()
{
  string firstName = "goto 50 @50 0;JMP goto 50 @50 0;JMP";
  string lastName = "@sum D=M @END D;JGT@sum D=M @END D;JGT@sum D=M @END D;JGT";
  integerVulnerability(firstName, lastName);
}

/* =====================================================
*              6. POINTER SUBTRIFUGE
*  ===================================================== */

/*************************************
 * POINTER VULNERABILTY
 * 1. - There must be a pointer used in the code
 * 2. - Through some vulnerability, there must be a way for user input to
        overwrite the pointer. This typically happens through a stack buffer
        vulnerability.
 * 3. - After the pointer is overwritten, the pointer must be dereferenced.
 ****************************************/
void pointerVulnerability(char user[], char pass[])
{
   char username[17]  = "";
   char password[8]   = "";

  for (int i = 0; i < sizeof(user); i++){  // 2. Overwrite
      username[i] = user[i];
      cout << user[i];
    }
  cout << endl;
  for (int i = 0; i < sizeof(pass); i++){  // 2. Overwrite
      password[i] = pass[i];
      cout << pass[i];
    }
  cout << endl;
   //prompt for username and password
   cout << "What is your username? ";
   cout << username << "\n";
   cout << "What is your password? ";
   cout << password << "\n";

  // list of valid users
   const char * passwords[3] = { "PASWORD", "1234567", "Rosebud" };
   const char * usernames[3] = { "Admin",   "User",     "Kane"  };

  // identify the user
   int id = -1;
   for (int i = 0; i < 3; i++)
      if (strcmp(username, usernames[i]) == 0 &&
          strcmp(password, passwords[i]) == 0)
          id = i;
   // make a decision
   switch (id)
   {
      case 0:
        cout << "Welcome, " << usernames[id] << " you have full access\n";
        break;
      case 1:
        cout << "Users have limited access to many things\n";
        break;
      case 2:
        cout << "Mr. " << usernames[id] << ", so kind of you to visit\n";
        break;
      default:
        cout << "You are not authorized to access anything on the system.\n";
   }
}

/**************************************
 * POINTER WORKING
 * Call pointerVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void pointerWorking()
{
   char username[17] = "Admin";
   char password[8] = "PASWORD";

  pointerVulnerability(username, password);

  cout << "\n[H@X] >> Attempting to run exploited code:\n";
  pointerExploit(); // Call on Exploit code
}

/**************************************
 * POINTER EXPLOIT
 * 1. - The attacker must exploit a vulnerability allowing unintended access to
        the pointer.
 * 2. - The attacker must be able to provide a new pointer referring to data
        altering the normal flow of the program.
 *************************************/
void pointerExploit()
{
  char username[40] = "Admin Ðýÿÿè¬‰T ‰ØÄT";
  char password[40] = "PASWORD ‰ØÄTÐýÿÿè¬";
  pointerVulnerability(username, password);
}

/* =====================================================
*              7.  STACK SMASHING
*  ===================================================== */

/*************************************
 * STACK VULNERABILTY
 * 1. - There must be a buffer (such as an array) on the stack.
 * 2. - The buffer must be reachable from an external input.
 * 3. - The mechanism to fill the buffer from the external input must not
        correctly check for the buffer size.
 * 4. - A buffer overrun (extend beyond the intended limits of the array) must
        extend to the return address on the stack.
 ****************************************/
void stackVulnerability(char str[])
{
  char compText[16];
  for (int i = 0; i < sizeof(str); i++)  // 2. Overwrite
      compText[i] = str[i];
  cout << "\nString Vulnerability output: " << compText << endl;
}

/**************************************
 * STACK WORKING
 * Call stackVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void stackWorking()
{
  char str[16] = "Safe";
  cout << "Entering a safe string (str[16]): " << endl;
  
  stackVulnerability(str);
  cout << "\n[H@X] >> Attempting to run exploited code:\n";
  stackExploit(); // Call on Exploit code
}

/**************************************
 * STACK EXPLOIT
 * 1. - The attacker must provide more data into the outwardly facing buffer
        than the buffer is designed to hold.
 * 2. - The attacker must know where the return address pointer resides on the
        stack. This should be just beyond the end of the buffer
 * 3. - The attacker must insert machine language instructions in the buffer.
        This may occur before, after, or even around the return address pointer.
        The machine language could be already compiled code in the program.
 * 4. - The attacker must overwrite the return address. The old value, directing
        the flow of the program after the function is returned, must be changed
        from the calling function to the provided machine language in step 3.
 *************************************/
void stackExploit()
{
  char str[80] = "Unsafe Ðýÿÿè¬‰ÿÿ1Û ýÿÿèŸ‰ÿÿ‹Mð1éèÍT ‰ØÄT";
  cout << "Entering an unsafe string (str[80]):  " << str;
  stackVulnerability(str);
}

/* =====================================================
*              7.  VTABLE SPRAYING
*  ===================================================== */

class Vulnerability
{
    /* Write a class called Vulnerability that is vulnerable to vtable smashing attack.
    This means that there must be a method or two in this class that is vulnerable. 
    Hint: You will need two classes to do this: a base class and a derived class. */
  public:     
    Vulnerability() {}
    virtual void safe() = 0;

    void setBuffer (long i, long * b){
        buffer[i] = *b;
    }
    private:
      long buffer[1];
};

class SafeClass : public Vulnerability
{
  public:
    SafeClass() {}
    void safe(){
        cout << "The code is safe" << endl;
    }
  
};

/*************************************
 * VTABLE VULNERABILTY
 * 1. - The vulnerable class must be polymorphic.
 * 2. - The class must have a buffer as a member variable.
 * 3. - Through some vulnerability, there must be a way for user input to
        overwrite parts of the V-Table.
 * 4. - After a virtual function pointer is overwritten, the virtual function must
        be called.
 ****************************************/
void vtableVulnerability(int i, long * b)
{
  SafeClass safe;
  // auto vul = new Vulnerability();
  // vul->setUsername(username);
  // vul->setPassword(password);
  // vul->getOutputs();
}

/**************************************
 * VTABLE WORKING
 * Call vtableVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void vtableWorking()
{
  SafeClass safe;
  safe.safe();
  cout << "\n[H@X] >> Attempting to run exploited code:\n";
  vtableExploit();
}

/**************************************
 * VTABLE EXPLOIT
 * 1. - Through some vulnerability, the V-Table pointer or a function pointer
        within the V-Table must be overwritten.    
 * 2. - The attacker must have the address to another V-Table pointer or a
        function pointer
 *************************************/
void vtableExploit()
{
  SafeClass s;
  long vExploit;
  // setBuffer(, );
}
