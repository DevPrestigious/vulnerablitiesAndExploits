#include <iostream>
#include <string.h>
#include <stdio.h>


using namespace std;

class Vulnerability
{
  /* Write a class called Vulnerability that is vulnerable to vtable smashing attack.
  This means that there must be a method or two in this class that is vulnerable. 
  Hint: You will need two classes to do this: a base class and a derived class. */
public:
 void vulnerabliityDefcon();
 void vulnerabilityNoob();
};

void copyString(char old[]);

void arrayVulnerability(int array[], bool authenticated);
  void arrayWorking();
  void arrayExploit();
void ansiVulnerability();
  void ansiWorking();
  void ansiExploit();
void arcVulnerability();
  void arcWorking();
  void arcExploit();
void heapVulnerability();
  void heapWorking();
  void heapExploit();
void integerVulnerability();
  void integerWorking();
  void integerExploit();
void pointerVulnerability(char username[], char password[]);
  void pointerWorking();
  void pointerExploit();
void stackVulnerability(char str[]);
  void stackWorking();
  void stackExploit();
void vtableVulnerability();
  void vtableWorking();
  void vtableExploit();

using namespace std;

int main() {

  int vulReference{0};
  cout << "#  VULNERABILITY MENU \n";
  cout << "================================= \n";
  cout << "1. Array Index \n";
  cout << "2. ANSI-Unicode conversion \n";
  cout << "3. ARC injection \n";
  cout << "4. Heap spraying \n";
  cout << "5. Integer overflow \n";
  cout << "6. Pointer subterfuge \n";
  cout << "7. Stack smashing \n";
  cout << "8. VTable spraying \n";
  cout << "0. QUIT PROGRAM \n";
  cout << "================================= \n";
  cout << "Select a vulnerability from the list, or type 0 to quit!\n";
  do{
    cout << "Menu Option: ";
    cin >> vulReference;
    switch(vulReference)
      {
        case 0 :
        cout << "Quitting program, thank you!\n";
        break;
        case 1 :
        cout << "Selected Array Index\n";
        arrayWorking();
        break;
        case 2 :
        cout << "Selected ANSI-Unicode conversion\n";
        ansiWorking();
        break;
        case 3 :
        cout << "Selected ARC injection\n";
        arcWorking();
        break;
        case 4 :
        cout << "Selected Heap spraying\n";
        heapWorking();
        break;
        case 5 :
        cout << "Selected Integer overflow\n";
        integerWorking();
        break;
        case 6 :
        cout << "Selected Pointer subterfuge\n";
        pointerWorking();
        break;
        case 7 :
        cout << "Selected Stack smashing\n";
        stackWorking();
        break;
        case 8 :
        cout << "Selected VTable spraying\n";
        vtableWorking();
        break;
        
        default :
        cout << "Invalid input" << endl;
        cout << "Select the vulnerability type you would like to mess with or enter 0 to Quit!\n";
      }
    cout << endl;
  } while (vulReference != 0);
  return 0;
} 

/*************************************
 * ARRAY VULNERABILTY
 * 1. There must be an array and an array index variable
 * 2. The array index variable must be reachable through external input.
 * 3. There must not be bounds checking on the array index variable.
 ****************************************/
void arrayVulnerability(int array[], bool authenticated)
{
  int index;
  cout << "Input array index number: ";
  cin >> index;
  array[index] = -1;
}

/**************************************
 * ARRAY WORKING
 * Call arrayVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void arrayWorking()
{
  int array[4];
  bool authenticated = false;
  
  arrayVulnerability(array, authenticated);
  cout << "\n[H@X] >> Attempting to run exploited code:\n";
  arrayExploit(); // Call on Exploit code
}

/**************************************
 * ARRAY EXPLOIT
 * 1. The attacker provides an array index value outside the expected range
 * 2. The attacker must be able to provide input or redirect
 *    existing input into the array at the index he provided
 * 3. The injected value must alter program state in a way
 *    that is desirable to the attacker
 *************************************/
void arrayExploit()
{
  int array[4];
  bool authenticated = false;
  arrayVulnerability(array, authenticated);
}

/*************************************
 * ANSI VULNERABILTY
 * 1. - There must be a buffer where the basetype is greater than one
 * 2. - Validation of the buffer must check the size of the buffer rather than the
        number of elements in the buffer.
 ****************************************/
void ansiVulnerability(/* feel free to add parameters */)
{
  
}

/**************************************
 * ANSI WORKING
 * Call ansiVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void ansiWorking()
{
  ansiVulnerability(/* parameters with non-malicious data */);
  cout << "\n[H@X] >> Attempting to run exploited code:\n";
  ansiExploit(); // Call on Exploit code
}


/**************************************
 * ANSI EXPLOIT
 * 1. - The attacker must provide more than half as much data into the
        outwardly facing buffer as it is designed to hold.
 * 2. - From here, a variety of injection attacks are possible. The most likely
        candidates are stack smashing or heap smashing. In the above example,
        the third parameter of the copyUnicodeText() function is the number
        of elements in the string (256 elements), not the size of the string (512
        bytes). The end result is a buffer overrun of 256 bytes.
 *************************************/
void ansiExploit()
{
   ansiVulnerability(/* parameters with malicious data */);
}

/*************************************
 * ARC VULNERABILTY
 * 1. - There must be a function pointer used in the code.
 * 2. - Through some vulnerability, there must be a way for user input to
        overwrite the function pointer. This typically happens through a stack
        buffer vulnerability.
 * 3. - After the memory is overwritten, the function pointer must be
        dereferenced.
 ****************************************/
void arcVulnerability(/* feel free to add parameters */)
{
  
}

/**************************************
 * ARC WORKING
 * Call arcVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void arcWorking()
{
  arcVulnerability(/* parameters with non-malicious data */);
  cout << "\n[H@X] >> Attempting to run exploited code:\n";
  arcExploit(); // Call on Exploit code
}

/**************************************
 * ARC EXPLOIT
 * 1. - The attacker must exploit a vulnerability allowing unintended access to
        the function pointer.
 * 2. - The attacker must have the address to another function which is to be
        used to replace the existing function pointer.
 *************************************/
void arcExploit()
{
   arcVulnerability(/* parameters with malicious data */);
}

/*************************************
 * HEAP VULNERABILTY
 * 1. - There must be two adjacent heap buffers.
 * 2. - The first buffer must be reachable through external input.
 * 3. - The mechanism to fill the buffer from the external input must not
        correctly check for the buffer size.
 * 4. - The second buffer must be released before the first.
 * 5. - The first buffer must be overrun (extend beyond the intended limits of
        the array).
 ****************************************/
void heapVulnerability(/* feel free to add parameters */)
{
  
}

/**************************************
 * HEAP WORKING
 * Call heapVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void heapWorking()
{
  heapVulnerability(/* parameters with non-malicious data */);
  cout << "\n[H@X] >> Attempting to run exploited code:\n";
  heapExploit(); // Call on Exploit code

}

/**************************************
 * HEAP EXPLOIT
 * 1. - The attacker must provide more data into the outwardly facing heap
        buffer than the buffer is designed to hold.
 * 2. - The attacker must know the layout of the Memory Control Block (MCB)
        (essentially a linked list) residing just after the buffer.
 * 3. - The attacker must provide a new MCB containing both the location of
        the memory overwrite and the new data to be overwritten.

 *************************************/
void heapExploit()
{
   heapVulnerability(/* parameters with malicious data */);
}

/*************************************
 * INTEGER VULNERABILTY
 * 1. - There must be a security check represented by an expression.
 * 2. - The expression must have the potential for overflow.
 * 3. - At least one of the numbers used to compute the sentinel must be
        reachable through external input. This sentinel is a variable used to make
        the security decision from the first requirement.
 ****************************************/
void integerVulnerability(/* feel free to add parameters */)
{
  
}

/**************************************
 * INTEGER WORKING
 * Call integerVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void integerWorking()
{
  integerVulnerability(/* parameters with non-malicious data */);
  cout << "\n[H@X] >> Attempting to run exploited code:\n";
  integerExploit(); // Call on Exploit code
}

/**************************************
 * INTEGER EXPLOIT
 * 1. - Provide input, either a buffer size or a single value, that is directly or
        indirectly used in the vulnerable expression.
 * 2. - The input must exceed the valid bounds of the data-type, resulting in an
        overflow or underflow condition.
 *************************************/
void integerExploit()
{
   integerVulnerability(/* parameters with malicious data */);
}

/*************************************
 * POINTER VULNERABILTY
 * 1. - There must be a pointer used in the code
 * 2. - Through some vulnerability, there must be a way for user input to
        overwrite the pointer. This typically happens through a stack buffer
        vulnerability.
 * 3. - After the pointer is overwritten, the pointer must be dereferenced.
 ****************************************/
void pointerVulnerability(char username[], char password[])
{
   char username[];
   char password[]
   //prompt for username and password
   cout << "What is your username? ";
   cout << username << "\n";
   cout << "What is your password? ";
   cout << password << "\n";

  // list of valid users
   const char * passwords[3] = { "PASWORD", "1234567", "Rosebud" };
   const char * usernames[3] = { "Admin",   "User",     "Kane"  };

  // identify the user
   int id = -1;
   for (int i = 0; i < 3; i++)
      if (strcmp(username, usernames[i]) == 0 &&
          strcmp(password, passwords[i]) == 0)
          id = i;
   // make a decision
   switch (id)
   {
      case 0:
        cout << "Welcome, " << usernames[id] << " you have full access\n";
        break;
      case 1:
        cout << "Users have limited access to many things\n";
        break;
      case 2:
        cout << "Mr. " << usernames[id] << ", so kind of you to visit\n";
        break;
      default:
        cout << "You are not authorized to access anything on the system.\n";
   }
}

/**************************************
 * POINTER WORKING
 * Call pointerVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void pointerWorking()
{
   char username[17] = "Admin";
   char password[8] = "PASWORD";

  pointerVulnerability(username, password);

  cout << "\n[H@X] >> Attempting to run exploited code:\n";
  pointerExploit(); // Call on Exploit code
}

/**************************************
 * POINTER EXPLOIT
 * 1. - The attacker must exploit a vulnerability allowing unintended access to
        the pointer.
 * 2. - The attacker must be able to provide a new pointer referring to data
        altering the normal flow of the program.
 *************************************/
void pointerExploit()
{
  char username[17] = "Admin";
  char password[17] = "PASWORD1";
  pointerVulnerability(username, password);
}

/*************************************
 * STACK VULNERABILTY
 * 1. - There must be a buffer (such as an array) on the stack.
 * 2. - The buffer must be reachable from an external input.
 * 3. - The mechanism to fill the buffer from the external input must not
        correctly check for the buffer size.
 * 4. - A buffer overrun (extend beyond the intended limits of the array) must
        extend to the return address on the stack.
 ****************************************/
void stackVulnerability(char str[])
{
  char compText[16];
  for (int i = 0; i < sizeof(str); i++)  // 2. Overwrite
      compText[i] = str[i];
}

/**************************************
 * STACK WORKING
 * Call stackVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void stackWorking()
{
  char str[16];
  cout << "Please enter a string [16]";
  cin >> str;
  cin.ignore(1,'\n');
  
  stackVulnerability(str);
  cout << "\n[H@X] >> Attempting to run exploited code:\n";
  stackExploit(); // Call on Exploit code
}

/**************************************
 * STACK EXPLOIT
 * 1. - The attacker must provide more data into the outwardly facing buffer
        than the buffer is designed to hold.
 * 2. - The attacker must know where the return address pointer resides on the
        stack. This should be just beyond the end of the buffer
 * 3. - The attacker must insert machine language instructions in the buffer.
        This may occur before, after, or even around the return address pointer.
        The machine language could be already compiled code in the program.
 * 4. - The attacker must overwrite the return address. The old value, directing
        the flow of the program after the function is returned, must be changed
        from the calling function to the provided machine language in step 3.
 *************************************/
void stackExploit()
{
  char str[8];
  stackVulnerability(str);
}

/*************************************
 * VTABLE VULNERABILTY
 * 1. - The vulnerable class must be polymorphic.
 * 2. - The class must have a buffer as a member variable.
 * 3. - Through some vulnerability, there must be a way for user input to
        overwrite parts of the V-Table.
 * 4. - After a virtual function pointer is overwritten, the virtual function must
        be called.
 ****************************************/
void vtableVulnerability(/* feel free to add parameters */)
{
  
}

/**************************************
 * VTABLE WORKING
 * Call vtableVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void vtableWorking()
{
  vtableVulnerability(/* parameters with non-malicious data */);
  cout << "\n[H@X] >> Attempting to run exploited code:\n";
  vtableExploit();
}

/**************************************
 * VTABLE EXPLOIT
 * 1. - Through some vulnerability, the V-Table pointer or a function pointer
        within the V-Table must be overwritten.    
 * 2. - The attacker must have the address to another V-Table pointer or a
        function pointer
 *************************************/
void vtableExploit()
{
  vtableVulnerability(/* parameters with malicious data */);
}

// COPY A STRING
void copyString(char old[]){
  char newText[sizeof(old)];
  for (int i = 0; i < sizeof(old); i++)  // 2. Overwrite
      newText[i] = old[i];
  return newText;
}
